Index: game.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>from __future__ import print_function\r\nfrom __future__ import division\r\n# game.py\r\n# -------\r\n# Licensing Information:  You are free to use or extend these projects for\r\n# educational purposes provided that (1) you do not distribute or publish\r\n# solutions, (2) you retain this notice, and (3) you provide clear\r\n# attribution to UC Berkeley.\r\n#\r\n# Attribution Information: The Pacman AI projects were developed at UC Berkeley.\r\n# The core projects and autograders were primarily created by John DeNero\r\n# (denero@cs.berkeley.edu) and Dan Klein (klein@cs.berkeley.edu).\r\n# Student side autograding was added by Brad Miller, Nick Hay, and\r\n# Pieter Abbeel (pabbeel@cs.berkeley.edu).\r\n\r\n\r\n# game.py\r\n# -------\r\n# Licensing Information: Please do not distribute or publish solutions to this\r\n# project. You are free to use and extend these projects for educational\r\n# purposes. The Pacman AI projects were developed at UC Berkeley, primarily by\r\n# John DeNero (denero@cs.berkeley.edu) and Dan Klein (klein@cs.berkeley.edu).\r\n\r\nfrom future import standard_library\r\n\r\n\r\nstandard_library.install_aliases()\r\nfrom builtins import str\r\nfrom builtins import range\r\nfrom past.utils import old_div\r\nfrom builtins import object\r\nfrom util import *\r\nimport time, os\r\nimport traceback\r\nimport sys\r\n\r\n#######################\r\n# Parts worth reading #\r\n#######################\r\n\r\nclass Agent(object):\r\n    \"\"\"\r\n    An agent must define a getAction method, but may also define the\r\n    following methods which will be called if they exist:\r\n\r\n    def registerInitialState(self, state): # inspects the starting state\r\n    \"\"\"\r\n    def __init__(self, index=0):\r\n        self.index = index\r\n\r\n    def getAction(self, state):\r\n        \"\"\"\r\n        The Agent will receive a GameState (from either {pacman, capture, sonar}.py) and\r\n        must return an action from Directions.{North, South, East, West, Stop}\r\n        \"\"\"\r\n        raiseNotDefined()\r\n\r\nclass Directions(object):\r\n    NORTH = 'North'\r\n    SOUTH = 'South'\r\n    EAST = 'East'\r\n    WEST = 'West'\r\n    STOP = 'Stop'\r\n\r\n    LEFT =       {NORTH: WEST,\r\n                   SOUTH: EAST,\r\n                   EAST:  NORTH,\r\n                   WEST:  SOUTH,\r\n                   STOP:  STOP}\r\n\r\n    RIGHT =      dict([(y,x) for x, y in list(LEFT.items())])\r\n\r\n    REVERSE = {NORTH: SOUTH,\r\n               SOUTH: NORTH,\r\n               EAST: WEST,\r\n               WEST: EAST,\r\n               STOP: STOP}\r\n\r\nclass Configuration(object):\r\n    \"\"\"\r\n    A Configuration holds the (x,y) coordinate of a character, along with its\r\n    traveling direction.\r\n\r\n    The convention for positions, like a graph, is that (0,0) is the lower left corner, x increases\r\n    horizontally and y increases vertically.  Therefore, north is the direction of increasing y, or (0,1).\r\n    \"\"\"\r\n\r\n    def __init__(self, pos, direction):\r\n        self.pos = pos\r\n        self.direction = direction\r\n\r\n    def getPosition(self):\r\n        return (self.pos)\r\n\r\n    def getDirection(self):\r\n        return self.direction\r\n\r\n    def isInteger(self):\r\n        x,y = self.pos\r\n        return x == int(x) and y == int(y)\r\n\r\n    def __eq__(self, other):\r\n        if other == None: return False\r\n        return (self.pos == other.pos and self.direction == other.direction)\r\n\r\n    def __hash__(self):\r\n        x = hash(self.pos)\r\n        y = hash(self.direction)\r\n        return hash(x + 13 * y)\r\n\r\n    def __str__(self):\r\n        return \"(x,y)=\"+str(self.pos)+\", \"+str(self.direction)\r\n\r\n    def generateSuccessor(self, vector):\r\n        \"\"\"\r\n        Generates a new configuration reached by translating the current\r\n        configuration by the action vector.  This is a low-level call and does\r\n        not attempt to respect the legality of the movement.\r\n\r\n        Actions are movement vectors.\r\n        \"\"\"\r\n        x, y= self.pos\r\n        dx, dy = vector\r\n        direction = Actions.vectorToDirection(vector)\r\n        if direction == Directions.STOP:\r\n            direction = self.direction # There is no stop direction\r\n        return Configuration((x + dx, y+dy), direction)\r\n\r\nclass AgentState(object):\r\n    \"\"\"\r\n    AgentStates hold the state of an agent (configuration, speed, scared, etc).\r\n    \"\"\"\r\n\r\n    def __init__( self, startConfiguration, isPacman ):\r\n        self.start = startConfiguration\r\n        self.configuration = startConfiguration\r\n        self.isPacman = isPacman\r\n        self.scaredTimer = 0\r\n        self.numCarrying = 0\r\n        self.numReturned = 0\r\n\r\n    def __str__( self ):\r\n        if self.isPacman:\r\n            return \"Pacman: \" + str( self.configuration )\r\n        else:\r\n            return \"Ghost: \" + str( self.configuration )\r\n\r\n    def __eq__( self, other ):\r\n        if other == None:\r\n            return False\r\n        return self.configuration == other.configuration and self.scaredTimer == other.scaredTimer\r\n\r\n    def __hash__(self):\r\n        return hash(hash(self.configuration) + 13 * hash(self.scaredTimer))\r\n\r\n    def copy( self ):\r\n        state = AgentState( self.start, self.isPacman )\r\n        state.configuration = self.configuration\r\n        state.scaredTimer = self.scaredTimer\r\n        state.numCarrying = self.numCarrying\r\n        state.numReturned = self.numReturned\r\n        return state\r\n\r\n    def getPosition(self):\r\n        if self.configuration == None: return None\r\n        return self.configuration.getPosition()\r\n\r\n    def getDirection(self):\r\n        return self.configuration.getDirection()\r\n\r\nclass Grid(object):\r\n    \"\"\"\r\n    A 2-dimensional array of objects backed by a list of lists.  Data is accessed\r\n    via grid[x][y] where (x,y) are positions on a Pacman map with x horizontal,\r\n    y vertical and the origin (0,0) in the bottom left corner.\r\n\r\n    The __str__ method constructs an output that is oriented like a pacman board.\r\n    \"\"\"\r\n    def __init__(self, width, height, initialValue=False, bitRepresentation=None):\r\n        if initialValue not in [False, True]: raise Exception('Grids can only contain booleans')\r\n        self.CELLS_PER_INT = 30\r\n\r\n        self.width = width\r\n        self.height = height\r\n        self.data = [[initialValue for y in range(height)] for x in range(width)]\r\n        if bitRepresentation:\r\n            self._unpackBits(bitRepresentation)\r\n\r\n    def __getitem__(self, i):\r\n        return self.data[i]\r\n\r\n    def __setitem__(self, key, item):\r\n        self.data[key] = item\r\n\r\n    def __str__(self):\r\n        out = [[str(self.data[x][y])[0] for x in range(self.width)] for y in range(self.height)]\r\n        out.reverse()\r\n        return '\\n'.join([''.join(x) for x in out])\r\n\r\n    def __eq__(self, other):\r\n        if other == None: return False\r\n        return self.data == other.data\r\n\r\n    def __hash__(self):\r\n        # return hash(str(self))\r\n        base = 1\r\n        h = 0\r\n        for l in self.data:\r\n            for i in l:\r\n                if i:\r\n                    h += base\r\n                base *= 2\r\n        return hash(h)\r\n\r\n    def copy(self):\r\n        g = Grid(self.width, self.height)\r\n        g.data = [x[:] for x in self.data]\r\n        return g\r\n\r\n    def deepCopy(self):\r\n        return self.copy()\r\n\r\n    def shallowCopy(self):\r\n        g = Grid(self.width, self.height)\r\n        g.data = self.data\r\n        return g\r\n\r\n    def count(self, item =True ):\r\n        return sum([x.count(item) for x in self.data])\r\n\r\n    def asList(self, key = True):\r\n        list = []\r\n        for x in range(self.width):\r\n            for y in range(self.height):\r\n                if self[x][y] == key: list.append( (x,y) )\r\n        return list\r\n\r\n    def packBits(self):\r\n        \"\"\"\r\n        Returns an efficient int list representation\r\n\r\n        (width, height, bitPackedInts...)\r\n        \"\"\"\r\n        bits = [self.width, self.height]\r\n        currentInt = 0\r\n        for i in range(self.height * self.width):\r\n            bit = self.CELLS_PER_INT - (i % self.CELLS_PER_INT) - 1\r\n            x, y = self._cellIndexToPosition(i)\r\n            if self[x][y]:\r\n                currentInt += 2 ** bit\r\n            if (i + 1) % self.CELLS_PER_INT == 0:\r\n                bits.append(currentInt)\r\n                currentInt = 0\r\n        bits.append(currentInt)\r\n        return tuple(bits)\r\n\r\n    def _cellIndexToPosition(self, index):\r\n        x = old_div(index, self.height)\r\n        y = index % self.height\r\n        return x, y\r\n\r\n    def _unpackBits(self, bits):\r\n        \"\"\"\r\n        Fills in data from a bit-level representation\r\n        \"\"\"\r\n        cell = 0\r\n        for packed in bits:\r\n            for bit in self._unpackInt(packed, self.CELLS_PER_INT):\r\n                if cell == self.width * self.height: break\r\n                x, y = self._cellIndexToPosition(cell)\r\n                self[x][y] = bit\r\n                cell += 1\r\n\r\n    def _unpackInt(self, packed, size):\r\n        bools = []\r\n        if packed < 0: raise ValueError(\"must be a positive integer\")\r\n        for i in range(size):\r\n            n = 2 ** (self.CELLS_PER_INT - i - 1)\r\n            if packed >= n:\r\n                bools.append(True)\r\n                packed -= n\r\n            else:\r\n                bools.append(False)\r\n        return bools\r\n\r\ndef reconstituteGrid(bitRep):\r\n    if type(bitRep) is not type((1,2)):\r\n        return bitRep\r\n    width, height = bitRep[:2]\r\n    return Grid(width, height, bitRepresentation= bitRep[2:])\r\n\r\n####################################\r\n# Parts you shouldn't have to read #\r\n####################################\r\n\r\nclass Actions(object):\r\n    \"\"\"\r\n    A collection of static methods for manipulating move actions.\r\n    \"\"\"\r\n    # Directions\r\n    _directions = {Directions.NORTH: (0, 1),\r\n                   Directions.SOUTH: (0, -1),\r\n                   Directions.EAST:  (1, 0),\r\n                   Directions.WEST:  (-1, 0),\r\n                   Directions.STOP:  (0, 0)}\r\n\r\n    _directionsAsList = list(_directions.items())\r\n\r\n    TOLERANCE = .001\r\n\r\n    def reverseDirection(action):\r\n        if action == Directions.NORTH:\r\n            return Directions.SOUTH\r\n        if action == Directions.SOUTH:\r\n            return Directions.NORTH\r\n        if action == Directions.EAST:\r\n            return Directions.WEST\r\n        if action == Directions.WEST:\r\n            return Directions.EAST\r\n        return action\r\n    reverseDirection = staticmethod(reverseDirection)\r\n\r\n    def vectorToDirection(vector):\r\n        dx, dy = vector\r\n        if dy > 0:\r\n            return Directions.NORTH\r\n        if dy < 0:\r\n            return Directions.SOUTH\r\n        if dx < 0:\r\n            return Directions.WEST\r\n        if dx > 0:\r\n            return Directions.EAST\r\n        return Directions.STOP\r\n    vectorToDirection = staticmethod(vectorToDirection)\r\n\r\n    def directionToVector(direction, speed = 1.0):\r\n        dx, dy =  Actions._directions[direction]\r\n        return (dx * speed, dy * speed)\r\n    directionToVector = staticmethod(directionToVector)\r\n\r\n    def getPossibleActions(config, walls):\r\n        possible = []\r\n        x, y = config.pos\r\n        x_int, y_int = int(x + 0.5), int(y + 0.5)\r\n\r\n        # In between grid points, all agents must continue straight\r\n        if (abs(x - x_int) + abs(y - y_int)  > Actions.TOLERANCE):\r\n            return [config.getDirection()]\r\n\r\n        for dir, vec in Actions._directionsAsList:\r\n            dx, dy = vec\r\n            next_y = y_int + dy\r\n            next_x = x_int + dx\r\n            if not walls[next_x][next_y]: possible.append(dir)\r\n\r\n        return possible\r\n\r\n    getPossibleActions = staticmethod(getPossibleActions)\r\n\r\n    def getLegalNeighbors(position, walls):\r\n        x,y = position\r\n        x_int, y_int = int(x + 0.5), int(y + 0.5)\r\n        neighbors = []\r\n        for dir, vec in Actions._directionsAsList:\r\n            dx, dy = vec\r\n            next_x = x_int + dx\r\n            if next_x < 0 or next_x == walls.width: continue\r\n            next_y = y_int + dy\r\n            if next_y < 0 or next_y == walls.height: continue\r\n            if not walls[next_x][next_y]: neighbors.append((next_x, next_y))\r\n        return neighbors\r\n    getLegalNeighbors = staticmethod(getLegalNeighbors)\r\n\r\n    def getSuccessor(position, action):\r\n        dx, dy = Actions.directionToVector(action)\r\n        x, y = position\r\n        return (x + dx, y + dy)\r\n    getSuccessor = staticmethod(getSuccessor)\r\n\r\nclass GameStateData(object):\r\n    \"\"\"\r\n\r\n    \"\"\"\r\n    def __init__( self, prevState = None ):\r\n        \"\"\"\r\n        Generates a new data packet by copying information from its predecessor.\r\n        \"\"\"\r\n        if prevState != None:\r\n            self.food = prevState.food.shallowCopy()\r\n            self.capsules = prevState.capsules[:]\r\n            self.agentStates = self.copyAgentStates( prevState.agentStates )\r\n            self.layout = prevState.layout\r\n            self._eaten = prevState._eaten\r\n            self.score = prevState.score\r\n\r\n        self._foodEaten = None\r\n        self._foodAdded = None\r\n        self._capsuleEaten = None\r\n        self._agentMoved = None\r\n        self._lose = False\r\n        self._win = False\r\n        self.scoreChange = 0\r\n\r\n    def deepCopy( self ):\r\n        state = GameStateData( self )\r\n        state.food = self.food.deepCopy()\r\n        state.layout = self.layout.deepCopy()\r\n        state._agentMoved = self._agentMoved\r\n        state._foodEaten = self._foodEaten\r\n        state._foodAdded = self._foodAdded\r\n        state._capsuleEaten = self._capsuleEaten\r\n        return state\r\n\r\n    def copyAgentStates( self, agentStates ):\r\n        copiedStates = []\r\n        for agentState in agentStates:\r\n            copiedStates.append( agentState.copy() )\r\n        return copiedStates\r\n\r\n    def __eq__( self, other ):\r\n        \"\"\"\r\n        Allows two states to be compared.\r\n        \"\"\"\r\n        if other == None: return False\r\n        # TODO Check for type of other\r\n        if not self.agentStates == other.agentStates: return False\r\n        if not self.food == other.food: return False\r\n        if not self.capsules == other.capsules: return False\r\n        if not self.score == other.score: return False\r\n        return True\r\n\r\n    def __hash__( self ):\r\n        \"\"\"\r\n        Allows states to be keys of dictionaries.\r\n        \"\"\"\r\n        for i, state in enumerate( self.agentStates ):\r\n            try:\r\n                int(hash(state))\r\n            except TypeError as e:\r\n                print(e)\r\n                #hash(state)\r\n        return int((hash(tuple(self.agentStates)) + 13*hash(self.food) + 113* hash(tuple(self.capsules)) + 7 * hash(self.score)) % 1048575 )\r\n\r\n    def __str__( self ):\r\n        width, height = self.layout.width, self.layout.height\r\n        map = Grid(width, height)\r\n        if type(self.food) == type((1,2)):\r\n            self.food = reconstituteGrid(self.food)\r\n        for x in range(width):\r\n            for y in range(height):\r\n                food, walls = self.food, self.layout.walls\r\n                map[x][y] = self._foodWallStr(food[x][y], walls[x][y])\r\n\r\n        for agentState in self.agentStates:\r\n            if agentState == None: continue\r\n            if agentState.configuration == None: continue\r\n            x,y = [int( i ) for i in nearestPoint( agentState.configuration.pos )]\r\n            agent_dir = agentState.configuration.direction\r\n            if agentState.isPacman:\r\n                map[x][y] = self._pacStr( agent_dir )\r\n            else:\r\n                map[x][y] = self._ghostStr( agent_dir )\r\n\r\n        for x, y in self.capsules:\r\n            map[x][y] = 'o'\r\n\r\n        return str(map) + (\"\\nScore: %d\\n\" % self.score)\r\n\r\n    def _foodWallStr( self, hasFood, hasWall ):\r\n        if hasFood:\r\n            return '.'\r\n        elif hasWall:\r\n            return '%'\r\n        else:\r\n            return ' '\r\n\r\n    def _pacStr( self, dir ):\r\n        if dir == Directions.NORTH:\r\n            return 'v'\r\n        if dir == Directions.SOUTH:\r\n            return '^'\r\n        if dir == Directions.WEST:\r\n            return '>'\r\n        return '<'\r\n\r\n    def _ghostStr( self, dir ):\r\n        return 'G'\r\n        if dir == Directions.NORTH:\r\n            return 'M'\r\n        if dir == Directions.SOUTH:\r\n            return 'W'\r\n        if dir == Directions.WEST:\r\n            return '3'\r\n        return 'E'\r\n\r\n    def initialize( self, layout, numGhostAgents ):\r\n        \"\"\"\r\n        Creates an initial game state from a layout array (see layout.py).\r\n        \"\"\"\r\n        self.food = layout.food.copy()\r\n        #self.capsules = []\r\n        self.capsules = layout.capsules[:]\r\n        self.layout = layout\r\n        self.score = 0\r\n        self.scoreChange = 0\r\n\r\n        self.agentStates = []\r\n        numGhosts = 0\r\n        for isPacman, pos in layout.agentPositions:\r\n            if not isPacman:\r\n                if numGhosts == numGhostAgents: continue # Max ghosts reached already\r\n                else: numGhosts += 1\r\n            self.agentStates.append( AgentState( Configuration( pos, Directions.STOP), isPacman) )\r\n        self._eaten = [False for a in self.agentStates]\r\n\r\ntry:\r\n    import boinc\r\n    _BOINC_ENABLED = True\r\nexcept:\r\n    _BOINC_ENABLED = False\r\n\r\n\r\nclass Game(object):\r\n    \"\"\"\r\n    The Game manages the control flow, soliciting actions from agents.\r\n    \"\"\"\r\n\r\n    def __init__( self, agents, display, rules, startingIndex=0, muteAgents=False, catchExceptions=False ):\r\n        self.agentCrashed = False\r\n        self.agents = agents\r\n        self.display = display\r\n        self.rules = rules\r\n        self.startingIndex = startingIndex\r\n        self.gameOver = False\r\n        self.muteAgents = muteAgents\r\n        self.catchExceptions = catchExceptions\r\n        self.moveHistory = []\r\n        self.totalAgentTimes = [0 for agent in agents]\r\n        self.totalAgentTimeWarnings = [0 for agent in agents]\r\n        self.agentTimeout = False\r\n        import io\r\n        self.agentOutput = [io.StringIO() for agent in agents]\r\n\r\n    def getProgress(self):\r\n        if self.gameOver:\r\n            return 1.0\r\n        else:\r\n            return self.rules.getProgress(self)\r\n\r\n    def _agentCrash( self, agentIndex, quiet=False):\r\n        \"Helper method for handling agent crashes\"\r\n        if not quiet: traceback.print_exc()\r\n        self.gameOver = True\r\n        self.agentCrashed = True\r\n        self.rules.agentCrash(self, agentIndex)\r\n\r\n    OLD_STDOUT = None\r\n    OLD_STDERR = None\r\n\r\n    def mute(self, agentIndex):\r\n        if not self.muteAgents: return\r\n        global OLD_STDOUT, OLD_STDERR\r\n        import io\r\n        OLD_STDOUT = sys.stdout\r\n        OLD_STDERR = sys.stderr\r\n        sys.stdout = self.agentOutput[agentIndex]\r\n        sys.stderr = self.agentOutput[agentIndex]\r\n\r\n    def unmute(self):\r\n        if not self.muteAgents: return\r\n        global OLD_STDOUT, OLD_STDERR\r\n        # Revert stdout/stderr to originals\r\n        sys.stdout = OLD_STDOUT\r\n        sys.stderr = OLD_STDERR\r\n\r\n\r\n    def run( self ):\r\n\r\n        \"\"\"\r\n        Main control loop for game play.\r\n        \"\"\"\r\n        self.display.initialize(self.state.data)\r\n        self.numMoves = 0\r\n\r\n        ###self.display.initialize(self.state.makeObservation(1).data)\r\n        # inform learning agents of the game start\r\n        for i in range(len(self.agents)):\r\n            agent = self.agents[i]\r\n            if not agent:\r\n                self.mute(i)\r\n                # this is a null agent, meaning it failed to load\r\n                # the other team wins\r\n                print(\"Agent %d failed to load\" % i, file=sys.stderr)\r\n                self.unmute()\r\n                self._agentCrash(i, quiet=True)\r\n                return\r\n\r\n            if (\"registerInitialState\" in dir(agent)):\r\n                self.mute(i)\r\n                if self.catchExceptions:\r\n                    try:\r\n                        timed_func = TimeoutFunction(agent.registerInitialState, int(self.rules.getMaxStartupTime(i)))\r\n                        try:\r\n                            start_time = time.time()\r\n                            timed_func(self.state.deepCopy())\r\n                            time_taken = time.time() - start_time\r\n                            self.totalAgentTimes[i] += time_taken\r\n                        except TimeoutFunctionException:\r\n                            print(\"Agent %d ran out of time on startup!\" % i, file=sys.stderr)\r\n                            self.unmute()\r\n                            self.agentTimeout = True\r\n                            self._agentCrash(i, quiet=True)\r\n                            return\r\n                    except Exception as data:\r\n                        self._agentCrash(i, quiet=False)\r\n                        self.unmute()\r\n                        return\r\n                else:\r\n                    agent.registerInitialState(self.state.deepCopy())\r\n                ## TODO: could this exceed the total time\r\n                self.unmute()\r\n\r\n        agentIndex = self.startingIndex\r\n        numAgents = len( self.agents )\r\n        step = 0\r\n        while not self.gameOver:\r\n            # Fetch the next agent\r\n            agent = self.agents[agentIndex]\r\n            move_time = 0\r\n            skip_action = False\r\n                \r\n            # Generate an observation of the state\r\n            if 'observationFunction' in dir( agent ):\r\n                self.mute(agentIndex)\r\n                if self.catchExceptions:\r\n                    try:\r\n                        timed_func = TimeoutFunction(agent.observationFunction, int(self.rules.getMoveTimeout(agentIndex)))\r\n                        try:\r\n                            start_time = time.time()\r\n                            observation = timed_func(self.state.deepCopy())\r\n                        except TimeoutFunctionException:\r\n                            skip_action = True\r\n                        move_time += time.time() - start_time\r\n                        self.unmute()\r\n                    except Exception as data:\r\n                        self._agentCrash(agentIndex, quiet=False)\r\n                        self.unmute()\r\n                        return\r\n                else:\r\n                    observation = agent.observationFunction(self.state.deepCopy())\r\n                self.unmute()\r\n            else:\r\n                observation = self.state.deepCopy()\r\n            # Solicit an action\r\n            action = None\r\n            step += 1\r\n            self.mute(agentIndex)\r\n            if self.catchExceptions:\r\n                try:\r\n                    timed_func = TimeoutFunction(agent.getAction, int(self.rules.getMoveTimeout(agentIndex)) - int(move_time))\r\n                    try:\r\n                        start_time = time.time()\r\n                        if skip_action:\r\n                            raise TimeoutFunctionException()\r\n                        action = timed_func( observation )\r\n                    except TimeoutFunctionException:\r\n                        print(\"Agent %d timed out on a single move!\" % agentIndex, file=sys.stderr)\r\n                        self.agentTimeout = True\r\n                        self._agentCrash(agentIndex, quiet=True)\r\n                        self.unmute()\r\n                        return\r\n\r\n                    move_time += time.time() - start_time\r\n\r\n                    if move_time > self.rules.getMoveWarningTime(agentIndex):\r\n                        self.totalAgentTimeWarnings[agentIndex] += 1\r\n                        print(\"Agent %d took too long to make a move! This is warning %d\" % (agentIndex, self.totalAgentTimeWarnings[agentIndex]), file=sys.stderr)\r\n                        if self.totalAgentTimeWarnings[agentIndex] > self.rules.getMaxTimeWarnings(agentIndex):\r\n                            print(\"Agent %d exceeded the maximum number of warnings: %d\" % (agentIndex, self.totalAgentTimeWarnings[agentIndex]), file=sys.stderr)\r\n                            self.agentTimeout = True\r\n                            self._agentCrash(agentIndex, quiet=True)\r\n                            self.unmute()\r\n                            return\r\n\r\n                    self.totalAgentTimes[agentIndex] += move_time\r\n                    #print \"Agent: %d, time: %f, total: %f\" % (agentIndex, move_time, self.totalAgentTimes[agentIndex])\r\n                    if self.totalAgentTimes[agentIndex] > self.rules.getMaxTotalTime(agentIndex):\r\n                        print(\"Agent %d ran out of time! (time: %1.2f)\" % (agentIndex, self.totalAgentTimes[agentIndex]), file=sys.stderr)\r\n                        self.agentTimeout = True\r\n                        self._agentCrash(agentIndex, quiet=True)\r\n                        self.unmute()\r\n                        return\r\n                    self.unmute()\r\n                except Exception as data:\r\n                    self._agentCrash(agentIndex)\r\n                    self.unmute()\r\n                    return\r\n            else:\r\n                action = agent.getAction(observation)\r\n            self.unmute()\r\n\r\n            # Execute the action\r\n            self.moveHistory.append( (agentIndex, action) )\r\n            if self.catchExceptions:\r\n                try:\r\n                    self.state = self.state.generateSuccessor( agentIndex, action )\r\n                except Exception as data:\r\n                    self.mute(agentIndex)\r\n                    self._agentCrash(agentIndex)\r\n                    self.unmute()\r\n                    return\r\n            else:\r\n                self.state = self.state.generateSuccessor( agentIndex, action )\r\n\r\n            # Change the display\r\n            self.display.update( self.state.data )\r\n            ###idx = agentIndex - agentIndex % 2 + 1\r\n            ###self.display.update( self.state.makeObservation(idx).data )\r\n\r\n            # Allow for game specific conditions (winning, losing, etc.)\r\n            self.rules.process(self.state, self)\r\n            # Track progress\r\n            if agentIndex == numAgents + 1: self.numMoves += 1\r\n            # Next agent\r\n            agentIndex = ( agentIndex + 1 ) % numAgents\r\n\r\n            if _BOINC_ENABLED:\r\n                boinc.set_fraction_done(self.getProgress())\r\n\r\n            # Allow the important information to be printed in the output file\r\n            if agentIndex == 0:\r\n                self.extractInfo()\r\n            # Allow to write the last 2 lines in the .arff file\r\n            if self.state.getLivingGhosts().count(True) == 0:\r\n                self.extractInfo()\r\n                self.extractInfo()\r\n\r\n        # inform a learning agent of the game result\r\n        for agentIndex, agent in enumerate(self.agents):\r\n            if \"final\" in dir( agent ) :\r\n                try:\r\n                    self.mute(agentIndex)\r\n                    agent.final( self.state )\r\n                    self.unmute()\r\n                except Exception as data:\r\n                    if not self.catchExceptions: raise\r\n                    self._agentCrash(agentIndex)\r\n                    self.unmute()\r\n                    return\r\n        self.display.finish()\r\n\r\n    def extractInfo(self):\r\n        from bustersAgents import BasicAgentAA\r\n        f_all = open(\"./ficheros/pruebas/test_othermaps_keyboard.arff\", \"a\")\r\n        f_all.write(BasicAgentAA.printLineData(self, self.state))\r\n        f_all.close()\r\n\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/game.py b/game.py
--- a/game.py	(revision 8813ad18eeed8217324f8fd955080426f974b977)
+++ b/game.py	(date 1617292266036)
@@ -751,7 +751,7 @@
 
     def extractInfo(self):
         from bustersAgents import BasicAgentAA
-        f_all = open("./ficheros/pruebas/test_othermaps_keyboard.arff", "a")
+        f_all = open("./ficheros/test_othermaps_tutorial1.arff", "a")
         f_all.write(BasicAgentAA.printLineData(self, self.state))
         f_all.close()
 
